import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as c,c as r,d as e,e as n,b as t,f as s}from"./app-b5233593.js";const l="/ZJH-InternetDos/assets/image/RabbitMQ_13.png",u="/ZJH-InternetDos/assets/image/RabbitMQ_14.png",p="/ZJH-InternetDos/assets/image/RabbitMQ_15.png",d="/ZJH-InternetDos/assets/image/RabbitMQ_16.png",h="/ZJH-InternetDos/assets/image/RabbitMQ_17.png",g={},b=s('<h3 id="exchanges概念" tabindex="-1"><a class="header-anchor" href="#exchanges概念" aria-hidden="true">#</a> Exchanges概念</h3><ul><li>生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中</li><li>生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。<br><img src="'+l+`" title="图片标题" width=""></li></ul><h3 id="exchanges的类型" tabindex="-1"><a class="header-anchor" href="#exchanges的类型" aria-hidden="true">#</a> Exchanges的类型</h3><ul><li>直接(direct)</li><li>主题(topic)</li><li>标题(headers)</li><li>扇出(fanout)</li></ul><h3 id="无名exchange" tabindex="-1"><a class="header-anchor" href="#无名exchange" aria-hidden="true">#</a> 无名exchange</h3><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">//“”默认交换机</span>
channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> queueName<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由routingKey(bindingkey)绑定key指定的，如果它存在的话</p><h3 id="临时队列" tabindex="-1"><a class="header-anchor" href="#临时队列" aria-hidden="true">#</a> 临时队列</h3><ul><li>具有随机名称的队列，一旦我们断开了消费者的连接，队列将被自动删除</li><li>创建临时队列的方式如下:</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>String queueName <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="绑定-bindings" tabindex="-1"><a class="header-anchor" href="#绑定-bindings" aria-hidden="true">#</a> 绑定(bindings)</h3><p>什么是bingding呢，binding其实是exchange和queue之间的桥梁，它告诉我们exchange和那个队列进行了绑定关系。<br><img src="`+u+'" title="图片标题" width=""></p><h3 id="fanout" tabindex="-1"><a class="header-anchor" href="#fanout" aria-hidden="true">#</a> Fanout</h3><p>Fanout这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的所有队列中<br><img src="'+p+'" title="图片标题" width=""></p>',14),_={href:"https://github.com/zengjunhuai/Code/tree/master/RabbitMQProject/Demo4",target:"_blank",rel:"noopener noreferrer"},m=e("h3",{id:"direct-exchange",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#direct-exchange","aria-hidden":"true"},"#"),n(" Direct exchange")],-1),k=e("p",null,[n("这种类型的工作方式是，消息只去到它绑定的routingKey队列中去。"),e("br"),e("img",{src:d,title:"图片标题",width:""})],-1),f=e("p",null,"在上面这张图中，我们可以看到X绑定了两个队列，绑定类型是direct。队列Q1绑定键为orange，队列Q2绑定键有两个:一个绑定键为black，另一个绑定键为green.",-1),x={href:"https://github.com/zengjunhuai/Code/tree/master/RabbitMQProject/Demo5",target:"_blank",rel:"noopener noreferrer"},v=s('<h3 id="topics" tabindex="-1"><a class="header-anchor" href="#topics" aria-hidden="true">#</a> Topics</h3><ul><li>尽管使用direct交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有info.base和info.advantage，某个队列只想info.base的消息，那这个时候direct就办不到了。这个时候就只能使用topic类型</li><li>发送到类型是topic交换机的消息的routing_key不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词，比如说：&quot;stock.usd.nyse&quot;, &quot;nyse.vmw&quot;, &quot;quick.orange.rabbit&quot;.这种类型的。当然这个单词列表最多不能超过255个字节。<br> 在这个规则列表中，其中有两个替换符是大家需要注意的 <ul><li>*(星号)可以代替一个单词</li><li>#(井号)可以替代零个或多个单词<br><img src="'+h+'" title="图片标题" width=""></li></ul></li></ul><p>上图所示：</p><ul><li>Q1--&gt;绑定的是 <ul><li>中间带orange带3个单词的字符串(<em>.orange.</em>)</li></ul></li><li>Q2--&gt;绑定的是 <ul><li>最后一个单词是rabbit的3个单词(<em>.</em>.rabbit)</li><li>第一个单词是lazy的多个单词(lazy.#)</li></ul></li></ul>',4),y={href:"https://github.com/zengjunhuai/Code/tree/master/RabbitMQProject/Demo6",target:"_blank",rel:"noopener noreferrer"};function Q(q,D){const a=o("ExternalLinkIcon");return c(),r("div",null,[b,e("p",null,[n("实战："),e("a",_,[n("代码"),t(a)])]),m,k,f,e("p",null,[n("实战："),e("a",x,[n("代码"),t(a)])]),v,e("p",null,[n("实战："),e("a",y,[n("代码"),t(a)])])])}const w=i(g,[["render",Q],["__file","RabbitMQ项目_交换机.html.vue"]]);export{w as default};
