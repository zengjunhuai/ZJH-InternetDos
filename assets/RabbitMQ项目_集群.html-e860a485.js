import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as n,f as e}from"./app-b5233593.js";const t="/ZJH-InternetDos/assets/image/RabbitMQ_21.png",i="/ZJH-InternetDos/assets/image/RabbitMQ_22.png",r="/ZJH-InternetDos/assets/image/RabbitMQ_23.png",l="/ZJH-InternetDos/assets/image/RabbitMQ_24.png",p={},o=e(`<h3 id="使用集群的原因" tabindex="-1"><a class="header-anchor" href="#使用集群的原因" aria-hidden="true">#</a> 使用集群的原因</h3><ul><li>修改3台机器的主机名称</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>vim <span class="token operator">/</span>etc<span class="token operator">/</span>hostname
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>配置各个节点的 hosts 文件，让各个节点都能互相识别对方</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>vim <span class="token operator">/</span>etc<span class="token operator">/</span>hosts
<span class="token number">10.211</span><span class="token number">.55</span><span class="token number">.74</span> node1
<span class="token number">10.211</span><span class="token number">.55</span><span class="token number">.75</span> node2
<span class="token number">10.211</span><span class="token number">.55</span><span class="token number">.76</span> node3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>以确保各个节点的cookie文件使用的是同一个值</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>在node1上执行远程操作命令
scp <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib<span class="token operator">/</span>rabbitmq<span class="token operator">/</span><span class="token punctuation">.</span>erlang<span class="token punctuation">.</span>cookie root<span class="token decorator"><span class="token at operator">@</span><span class="token function">node2</span></span><span class="token operator">:</span><span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib<span class="token operator">/</span>rabbitmq<span class="token operator">/</span><span class="token punctuation">.</span>erlang<span class="token punctuation">.</span>cookie
scp <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib<span class="token operator">/</span>rabbitmq<span class="token operator">/</span><span class="token punctuation">.</span>erlang<span class="token punctuation">.</span>cookie root<span class="token decorator"><span class="token at operator">@</span><span class="token function">node3</span></span><span class="token operator">:</span><span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib<span class="token operator">/</span>rabbitmq<span class="token operator">/</span><span class="token punctuation">.</span>erlang<span class="token punctuation">.</span>cookie
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>启动RabbitMQ服务,顺带启动Erlang虚拟机和RbbitMQ应用服务(在三台节点上分别执行以下命令)</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>rabbitmq<span class="token operator">-</span>server <span class="token operator">-</span>detached
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>在节点2执行</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>rabbitmqctl <span class="token function">stop_app</span>
<span class="token punctuation">(</span>rabbitmqctl stop会将Erlang虚拟机关闭，rabbitmqctl stop_app只关闭RabbitMQ服务<span class="token punctuation">)</span>
rabbitmqctl reset
rabbitmqctl join_cluster rabbit<span class="token decorator"><span class="token at operator">@</span><span class="token function">node1</span></span>
rabbitmqctl <span class="token function">start_app</span><span class="token punctuation">(</span>只启动应用服务<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在节点3执行</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>rabbitmqctl stop_app
rabbitmqctl reset
rabbitmqctl join_cluster rabbit<span class="token decorator"><span class="token at operator">@</span><span class="token function">node2</span></span>
rabbitmqctl start_app
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>集群状态</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>rabbitmqctl cluster_status
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>需要重新设置用户</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>创建账号
rabbitmqctl add_user admin <span class="token number">123</span>
设置用户角色
rabbitmqctl set_user_tags admin administrator
设置用户权限
rabbitmqctl set_permissions <span class="token operator">-</span>p <span class="token string">&quot;/&quot;</span> admin <span class="token string">&quot;.*&quot;</span> <span class="token string">&quot;.*&quot;</span> <span class="token string">&quot;.*&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解除集群节点(node2和node3机器分别执行)</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>rabbitmqctl stop_app
rabbitmqctl reset
rabbitmqctl start_app
rabbitmqctl cluster_status
rabbitmqctl forget_cluster_node rabbit<span class="token decorator"><span class="token at operator">@</span><span class="token function">node2</span></span><span class="token punctuation">(</span>node1机器上执行<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="镜像队列" tabindex="-1"><a class="header-anchor" href="#镜像队列" aria-hidden="true">#</a> 镜像队列</h3><ul><li>如果RabbitMQ集群中只有一个Broker节点，那么该节点的失效将导致整体服务的临时性不可用，并且也可能会导致消息的丢失。可以将所有消息都设置为持久化，并且对应队列的durable属性也设置为true，但是这样仍然无法避免由于缓存导致的问题：因为消息在发送之后和被写入磁盘井执行刷盘动作之间存在一个短暂却会产生问题的时间窗。通过publisherconfirm机制能够确保客户端知道哪些消息己经存入磁盘，尽管如此，一般不希望遇到因单点故障导致的服务不可用。</li><li>引入镜像队列(Mirror Queue)的机制，可以将队列镜像到集群中的其他Broker节点之上，如果集群中的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。</li></ul><h3 id="镜像队列搭建步骤" tabindex="-1"><a class="header-anchor" href="#镜像队列搭建步骤" aria-hidden="true">#</a> 镜像队列搭建步骤</h3><ol><li><p>启动三台集群节点</p></li><li><p>随便找一个节点添加policy<br><img src="`+t+'" title="图片标题" width=""></p></li><li><p>在node1上创建一个队列发送一条消息，队列存在镜像队列<br><img src="'+i+'" title="图片标题" width=""></p></li><li><p>停掉node1之后发现node2成为镜像队列<br><img src="'+r+'" title="图片标题" width=""></p></li><li><p>就算整个集群只剩下一台机器了 依然能消费队列里面的消息，说明队列里面的消息被镜像队列传递到相应机器里面了</p></li></ol><h3 id="haproxy-keepalive实现高可用负载均衡" tabindex="-1"><a class="header-anchor" href="#haproxy-keepalive实现高可用负载均衡" aria-hidden="true">#</a> Haproxy+Keepalive实现高可用负载均衡</h3><img src="'+l+'" title="图片标题" width="">',25),c=[o];function d(u,b){return a(),n("div",null,c)}const k=s(p,[["render",d],["__file","RabbitMQ项目_集群.html.vue"]]);export{k as default};
