import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as p,c,b as s,d as n,e as a,f as i}from"./app-b5233593.js";const r="/ZJH-InternetDos/assets/image/RabbitMQ_19.png",u="/ZJH-InternetDos/assets/image/RabbitMQ_20.png",d={},m=i(`<h3 id="延迟队列概念" tabindex="-1"><a class="header-anchor" href="#延迟队列概念" aria-hidden="true">#</a> 延迟队列概念</h3><ul><li>延时队列就是用来存放需要在指定时间被处理的元素的队列。</li></ul><h3 id="延迟队列使用场景" tabindex="-1"><a class="header-anchor" href="#延迟队列使用场景" aria-hidden="true">#</a> 延迟队列使用场景</h3><ul><li>订单在十分钟之内未支付则自动取消</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</li></ul><h3 id="rabbitmq中的ttl" tabindex="-1"><a class="header-anchor" href="#rabbitmq中的ttl" aria-hidden="true">#</a> RabbitMQ中的TTL</h3><p>TTL是什么呢？TTL是RabbitMQ中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。换句话说，如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没有被消费，则会成为&quot;死信&quot;。如果同时配置了队列的TTL和消息的TTL，那么较小的那个值将会被使用，有两种方式设置TTL。</p><ul><li>消息设置TTL</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">&quot;X&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;XA&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;消息来自ttl为10S的队列: &quot;</span><span class="token operator">+</span>message<span class="token punctuation">,</span>correlationData<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
    correlationData<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setExpiration</span><span class="token punctuation">(</span>ttlTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> correlationData<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>队列设置TTL</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">//声明队列的TTL</span>
args<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;x-message-ttl&quot;</span><span class="token punctuation">,</span> <span class="token number">40000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> QueueBuilder<span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token constant">QUEUE_B</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withArguments</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>两者的区别<br> 如果设置了队列的TTL属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而消息设置TTL，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；另外，还需要注意的一点是，如果不设置TTL，表示消息永远不会过期，如果将TTL设置为0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</li></ul><h3 id="队列ttl实战" tabindex="-1"><a class="header-anchor" href="#队列ttl实战" aria-hidden="true">#</a> 队列TTL实战</h3>`,12),h={href:"https://github.com/zengjunhuai/Code/tree/master/RabbitMQProject/Demo8",target:"_blank",rel:"noopener noreferrer"},b=n("br",null,null,-1),k=n("br",null,null,-1),_=n("h3",{id:"队列ttl优化1-消息ttl",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#队列ttl优化1-消息ttl","aria-hidden":"true"},"#"),a(" 队列TTL优化1（消息TTL）")],-1),g={href:"https://github.com/zengjunhuai/Code/tree/master/RabbitMQProject/Demo9",target:"_blank",rel:"noopener noreferrer"},T=n("br",null,null,-1),f=n("h3",{id:"队列ttl优化2-x-delayed-message",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#队列ttl优化2-x-delayed-message","aria-hidden":"true"},"#"),a(" 队列TTL优化2（x-delayed-message）")],-1),v=n("p",null,"这是一种新的交换类型，该类型消息支持延迟投递机制 消息传递后并不会立即投递到目标队列中，而是存储在mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。",-1),q={href:"https://github.com/zengjunhuai/Code/tree/master/RabbitMQProject/Demo10",target:"_blank",rel:"noopener noreferrer"},y=n("br",null,null,-1),L={href:"https://www.rabbitmq.com/community-plugins.html",target:"_blank",rel:"noopener noreferrer"},Q=n("br",null,null,-1),A=i(`<ul><li>进入rabbitmq目录/plugins后执行以下命令：</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>rabbitmq<span class="token operator">-</span>plugins enable rabbitmq_delayed_message_exchange
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="`+r+'" title="图片标题" width=""><p>实验结果：<br><img src="'+u+'" title="图片标题" width=""></p>',4);function x(M,R){const e=o("Mermaid"),t=o("ExternalLinkIcon");return p(),c("div",null,[m,s(e,{id:"mermaid-57",code:"eJxTAIO0nPzy5IzEohIFnyBrLogYGAQU5aeUJqcW6eraKbhWAJXkpafGR+jqKkQ46pdUFqTapmQWpSaXKADlA0tTS1PjAx31DQ2KgQoiXUCCcD2RQCEkDfoQ6UAw6ZyfV1yam1qEYjMyQLXZCYfNTvomWG1W4AIAQFBBMQ=="}),n("p",null,[n("a",h,[a("代码"),s(t)]),b,a(" 结果：第一条消息在10S后变成了死信消息，然后被消费者消费掉，第二条消息在40S之后变成了死信消息，然后被消费掉，这样一个延时队列就打造完成了。"),k,a(" 缺点：每增加一个新的时间需求，就要新增一个队列，这里只有10S和40S两个时间选项，如果需要一个小时后处理，那么就需要增加TTL为一个小时的队列。")]),_,s(e,{id:"mermaid-64",code:"eJxTAIO0nPzy5IzEohIFnyBrLogYGAQU5aeUJqcW6eraKbhWAJXkpafGRyjo6ipEOOqXVBak2qZkFqUmlwBF7AJLU0tT4wMd9Q0NioEKIl1AgnBNkUAhJA36EOlAMOmcn1dcmptahGI1MkCz2gmH1U76JlitViDSXGcc5jpjNRMAUq1XjQ=="}),n("p",null,[n("a",g,[a("代码"),s(t)]),T,a(" 实验结果：在消息属性上设置TTL的方式，消息可能并不会按时“死亡“，因为RabbitMQ只会检查第一个消息是否过期，如果过期则丢到死信队列，如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。")]),f,v,s(e,{id:"mermaid-74",code:"eJxTAIO0nPzy5IzEohIFnyBrLogYGAQU5aeUJqcW6eoqlFQWpNpW6Kak5iRWpqbo5qYWFyempyro6tpBhfRSK4Bm5KWnAhXDhIryS0sy89KzUyuRFRaWppYCVdk55+cVl+amFlkj2YgJuAAz+y+4"}),n("p",null,[n("a",q,[a("代码"),s(t)]),y,a(" 插件下载地址："),n("a",L,[a("https://www.rabbitmq.com/community-plugins.html"),s(t)]),Q,a(" 使用插件方法：")]),A])}const B=l(d,[["render",x],["__file","RabbitMQ项目_延迟队列.html.vue"]]);export{B as default};
