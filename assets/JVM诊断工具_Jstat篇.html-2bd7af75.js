import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as n,c as r,d as e,e as a,b as c,f as o}from"./app-b5233593.js";const s={},d=e("h2",{id:"简介",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#简介","aria-hidden":"true"},"#"),a(" 简介")],-1),p=e("p",null,"jstat（JVM Statistics Monitoring Tool）：用于监控虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进行的类装载、内存、垃圾收集、JIT编译等运行数据",-1),h=e("p",null,"在没有GUI图形界面，只提供纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测垃圾回收问题以及内存泄漏问题。",-1),u=e("br",null,null,-1),_={href:"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html",target:"_blank",rel:"noopener noreferrer"},g=o(`<h2 id="测试" tabindex="-1"><a class="header-anchor" href="#测试" aria-hidden="true">#</a> 测试</h2><p>（图片资源放上去速度慢，待完善）</p><h2 id="基本用法" tabindex="-1"><a class="header-anchor" href="#基本用法" aria-hidden="true">#</a> 基本用法</h2><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="option参数" tabindex="-1"><a class="header-anchor" href="#option参数" aria-hidden="true">#</a> option参数</h3><p>选项option可以由以下值构成<br> 类加载相关的：<br> -class：显示ClassLoader的相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间等</p><p>垃圾回收相关的:<br> -gc：显示与GC相关的堆信息。包括Eden区、两个Survivor区、老年代、永久代等容量、已用空间、GC时间合计等信息</p><p>-gccapacity：显示内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。<br> -gcutil：显示内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比。</p><p>-gccause：与-gcutil功能一样，但是会额外输出导致最后一次或当前正在发生的GC产生的原因</p><p>-gcnew：显示新生代GC状态</p><p>-gcnewcapacity：显示内容与-gcnew基本相同，输出主要关注使用到的最大，最小空间</p><p>-geold：显示老年代GC状况</p><p>-gcoldcapacity：显示内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</p><p>-gcpermcapacity：显示永久代使用的最大、最小空间</p><p>JIT相关：<br> -compiler：显示JIT编译器编译过的方法、耗时等信息<br> -printcompilation：输出已经被JIT编译的方法</p><ul><li>-gc <ul><li><p>新生代相关：</p><ul><li>S0C是第一个幸存者区的大小（字节）</li><li>​S1C是第二个幸存者区的大小（字节）</li><li>​S0U是第一个幸存者区已使用的大小（字节）</li><li>​S1U是第一个幸存者区已使用的大小（字节）</li><li>EC是Eden空间的大小（字节）</li><li>​EU是Eden空间已使用的大小（字节）</li></ul></li><li><p>老年代相关</p><ul><li>OC是老年代的大小（字节）</li><li>OU是老年代已使用的大小（字节）</li></ul></li><li><p>方法区（元空间）相关</p><ul><li>MC是方法区的大小</li><li>MC是方法区的大小</li><li>CCSC是压缩类空间的大小</li><li>CCSU是压缩类空间已使用的大小</li></ul></li><li><p>其他</p><ul><li>YGC是指从应用程序启动到采样时young gc次数</li><li>YGCT是指应用程序启动到采样时young gc消耗的时间（秒）</li><li>FGC是指从应用程序启动到采样时full gc次数</li><li>FGCT是指从应用程序启动到采样时full gc消耗的时间（秒）</li><li>GCT是指从应用程序启动到采样时gc的总时间</li></ul></li></ul></li></ul><h3 id="interval参数" tabindex="-1"><a class="header-anchor" href="#interval参数" aria-hidden="true">#</a> interval参数</h3><p>用于指定输出统计数据的周期，单位为毫秒。即：查询间隔</p><h3 id="count参数" tabindex="-1"><a class="header-anchor" href="#count参数" aria-hidden="true">#</a> count参数</h3><p>用于指定查询的总次数</p><h3 id="t参数" tabindex="-1"><a class="header-anchor" href="#t参数" aria-hidden="true">#</a> -t参数</h3><p>可以在输出信息加上一个Timestamp列，显示程序的运行时间。单位：秒</p><p>我们可以比较Java进行的启动时间以及总GC时间（GCT列），或者两次测量的间隔时间以及总GC时间的增量，来得出GC时间占运行时间的比例</p><p>如果该比例超过20%，则说明目前堆的压力较大；如果该比例超过90%，则说明堆几乎没有可用空间，随时都可能抛出OOM异常。</p><h3 id="h参数" tabindex="-1"><a class="header-anchor" href="#h参数" aria-hidden="true">#</a> -h参数</h3><p>可以在周期性数据输出时，输出多少行数据后输出一个表头信息</p><h3 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h3><p>jstat还可以用来判断是否出现内存泄漏</p><p>第一步：<br> 在长时间运行的Java程序中，我们可以运行jstat命令连续获取多行性能数据，并取这几行数据中OU列（即已占用的老年代内存）的最小值</p><p>第二步：<br> 然后，我们每隔一段较长的时间重复一次上述操作，来获得多组OU最小值。如果这些值呈上涨趋势，则说明Java程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。</p>`,30);function C(m,b){const i=l("ExternalLinkIcon");return n(),r("div",null,[d,p,h,e("p",null,[a("官方文档："),u,e("a",_,[a("https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html"),c(i)])]),g])}const x=t(s,[["render",C],["__file","JVM诊断工具_Jstat篇.html.vue"]]);export{x as default};
