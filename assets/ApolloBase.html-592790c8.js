import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as i,c as t,d as e,e as r,b as n,f as p}from"./app-b5233593.js";const c="/ZJH-InternetDos/assets/image/apollo_03.png",s="/ZJH-InternetDos/assets/image/apollo_04.png",d={},h={href:"https://github.com/ctripcorp/apollo",target:"_blank",rel:"noopener noreferrer"},b=p('<h2 id="apollo特性" tabindex="-1"><a class="header-anchor" href="#apollo特性" aria-hidden="true">#</a> Apollo特性</h2><p>基于配置的特殊性，所以Apollo从设计之初就立志于成为一个有治理能力的配置发布平台，目前提供了以下的特性：</p><ul><li><p>统一管理不同环境、不同集群的配置<br> 1、Apollo提供了一个统一界面集中式管理不同环境（environment）、不同集群（cluster）、不同命名空 间（namespace）的配置。<br> 2、同一份代码部署在不同的集群，可以有不同的配置，比如zookeeper的地址等<br> 3、通过命名空间（namespace）可以很方便地支持多个不同应用共享同一份配置，同时还允许应用对共享 的配置进行覆盖</p></li><li><p>配置修改实时生效（热发布）<br> 用户在Apollo修改完配置并发布后，客户端能实时（1秒）接收到最新的配置， 并通知到应用程序。</p></li><li><p>版本发布管理<br> 所有的配置发布都有版本概念，从而可以方便地支持配置的回滚</p></li><li><p>灰度发布<br> 支持配置的灰度发布，比如点了发布后，只对部分应用实例生效，等观察一段时间没问题后再推给所有应用实例</p></li><li><p>权限管理、发布审核、操作审计<br> 应用和配置的管理都有完善的权限管理机制，对配置的管理还分为了编辑和发布两个环节，从而减少人 为的错误。 所有的操作都有审计日志，可以方便地追踪问题</p></li><li><p>客户端配置信息监控<br> 可以在界面上方便地看到配置在被哪些实例使用</p></li><li><p>提供Java和.Net原生客户端<br> 提供了Java和.Net的原生客户端，方便应用集成</p></li><li><p>提供开放平台API<br> Apollo自身提供了比较完善的统一配置管理界面，支持多环境、多数据中心配置管理、权限、流程治理 等特性。不过Apollo出于通用性考虑，不会对配置的修改做过多限制，只要符合基本的格式就能保存， 不会针对不同的配置值进行针对性的校验，如数据库用户名、密码，Redis服务地址等 对于这类应用配置，Apollo支持应用方通过开放平台API在Apollo进行配置的修改和发布，并且具备完善的授权和权限控制。</p></li></ul><h2 id="apollo工作原理" tabindex="-1"><a class="header-anchor" href="#apollo工作原理" aria-hidden="true">#</a> Apollo工作原理</h2><img src="'+c+'" title="图片标题" width=""><h3 id="各模块职责" tabindex="-1"><a class="header-anchor" href="#各模块职责" aria-hidden="true">#</a> 各模块职责</h3><p>1、Config Service提供配置的读取、推送等功能，服务对象是Apollo客户端<br> 2、Admin Service提供配置的修改、发布等功能，服务对象是Apollo Portal（管理界面）<br> 3、Eureka提供服务注册和发现，为了简单起见，目前Eureka在部署时和Config Service是在一个JVM进程中的<br> 4、Config Service和Admin Service都是多实例、无状态部署，所以需要将自己注册到Eureka中并保持心跳 在Eureka之上架了一层Meta Server用于封装Eureka的服务发现接口<br> 5、Client通过域名访问Meta Server获取Config Service服务列表（IP+Port），而后直接通过IP+Port访问服务， 同时在Client侧会做load balance、错误重试<br> 6、Portal通过域名访问Meta Server获取Admin Service服务列表（IP+Port），而后直接通过IP+Port访问服务， 同时在Portal侧会做load balance、错误重试<br> 7、为了简化部署，我们实际上会把Config Service、Eureka和Meta Server三个逻辑角色部署在同一个JVM进程中</p><h3 id="分步执行流程" tabindex="-1"><a class="header-anchor" href="#分步执行流程" aria-hidden="true">#</a> 分步执行流程</h3><p>1、Apollo启动后，Config/Admin Service会自动注册到Eureka服务注册中心，并定期发送保活心跳。<br> 2、Apollo Client和Portal管理端通过配置的Meta Server的域名地址经由Software Load Balancer(软件负载均衡 器)进行负载均衡后分配到某一个Meta Server<br> 3、Meta Server从Eureka获取Config Service和Admin Service的服务信息，相当于是一个Eureka Client<br> 4、Meta Server获取Config Service和Admin Service（IP+Port）失败后会进行重试<br> 5、获取到正确的Config Service和Admin Service的服务信息后，Apollo Client通过Config Service为应用提供配 置获取、实时更新等功能；Apollo Portal管理端通过Admin Service提供配置新增、修改、发布等功能</p><h2 id="apollo核心概念" tabindex="-1"><a class="header-anchor" href="#apollo核心概念" aria-hidden="true">#</a> apollo核心概念</h2><ul><li>application (应用)<br> 这个很好理解，就是实际使用配置的应用，Apollo客户端在运行时需要知道当前应用是谁，从而可以去获取 对应的配置。关键字：appId</li><li>environment (环境)<br> 配置对应的环境，Apollo客户端在运行时需要知道当前应用处于哪个环境，从而可以去获取应用的配置。关键字：env</li><li>cluster (集群)<br> 一个应用下不同实例的分组，比如典型的可以按照数据中心分，把上海机房的应用实例分为一个集群，把北 京机房的应用实例分为另一个集群。关键字：cluster</li><li>namespace (命名空间)<br> 一个应用下不同配置的分组，可以简单地把namespace类比为文件，不同类型的配置存放在不同的文件中， 如数据库配置文件，RPC配置文件，应用自身的配置文件等。</li></ul><h2 id="配置发布原理" tabindex="-1"><a class="header-anchor" href="#配置发布原理" aria-hidden="true">#</a> 配置发布原理</h2><img src="'+s+'" title="图片标题" width=""><p>1、用户在Portal操作配置发布<br> 2、Portal调用Admin Service的接口操作发布<br> 3、Admin Service发布配置后，发送ReleaseMessage给各个Config Service<br> 4、Config Service收到ReleaseMessage后，通知对应的客户端</p>',14);function v(m,A){const a=l("ExternalLinkIcon");return i(),t("div",null,[e("p",null,[r("官方地址："),e("a",h,[r("https://github.com/ctripcorp/apollo"),n(a)])]),b])}const u=o(d,[["render",v],["__file","ApolloBase.html.vue"]]);export{u as default};
