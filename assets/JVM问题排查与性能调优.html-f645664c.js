import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as h,o as d,c as n,d as a,e,b as t,f as i}from"./app-b5233593.js";const c={},o=i('<h1 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h1><h2 id="为什么调优" tabindex="-1"><a class="header-anchor" href="#为什么调优" aria-hidden="true">#</a> 为什么调优</h2><h2 id="性能优化步骤" tabindex="-1"><a class="header-anchor" href="#性能优化步骤" aria-hidden="true">#</a> 性能优化步骤</h2><h3 id="发现问题-性能监控" tabindex="-1"><a class="header-anchor" href="#发现问题-性能监控" aria-hidden="true">#</a> （发现问题）性能监控</h3><ul><li>GC频繁</li><li>CPU load过高</li><li>内存泄漏</li><li>死锁</li><li>程序响应时间较长</li></ul><h3 id="排查问题-性能分析" tabindex="-1"><a class="header-anchor" href="#排查问题-性能分析" aria-hidden="true">#</a> （排查问题）性能分析</h3>',6),s={href:"http://gceasy.xn--io-403c94fbx2aorjwia",target:"_blank",rel:"noopener noreferrer"},u=a("li",null,"灵活运用命令行工具，jstack，jmap，jinfo等",-1),_=a("li",null,"dump出错文件，使用内存分析工具分析文件。",-1),f=a("li",null,"使用阿里Arthas，或jconsole，jVisualVM来实现查看JVM状态",-1),x=a("li",null,"jstack查看堆栈信息",-1),C=i('<h3 id="解决问题-性能调优" tabindex="-1"><a class="header-anchor" href="#解决问题-性能调优" aria-hidden="true">#</a> （解决问题）性能调优</h3><ul><li>适当增加内存，根据业务背景选择垃圾回收器</li><li>优化代码，控制内存使用</li><li>增加机器，分散节点压力</li><li>合理设置线程池线程数量</li><li>使用中间间件提高效率，比如缓存、消息队列等</li><li>其他</li></ul><h3 id="性能评价指标" tabindex="-1"><a class="header-anchor" href="#性能评价指标" aria-hidden="true">#</a> 性能评价指标</h3><ul><li>停顿时间（响应时间）</li><li>吞吐量</li><li>并发量</li><li>内存占用</li><li>相互间关系</li></ul><h2 id="分析gc日志" tabindex="-1"><a class="header-anchor" href="#分析gc日志" aria-hidden="true">#</a> 分析GC日志</h2><h3 id="gc分类" tabindex="-1"><a class="header-anchor" href="#gc分类" aria-hidden="true">#</a> GC分类</h3><p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p><ul><li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为： <ul><li>新生代收集（Minor GC / Young GC）:只是新生代（Eden\\S0，S1）的垃圾收集。</li><li>老年代收集（Major GC / Old GC）：只是老年代的垃圾收集。 <ul><li>目前，只有CMS GC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（Mix GC）：收集整个新生代以及部分老年代的垃圾收集。 <ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC）:收集整个java堆和方法区的垃圾收集。</li></ul><h3 id="minor-gc日志解析" tabindex="-1"><a class="header-anchor" href="#minor-gc日志解析" aria-hidden="true">#</a> Minor GC日志解析</h3><h3 id="full-gc日志解析" tabindex="-1"><a class="header-anchor" href="#full-gc日志解析" aria-hidden="true">#</a> Full GC日志解析</h3><h3 id="gc日志分析工具" tabindex="-1"><a class="header-anchor" href="#gc日志分析工具" aria-hidden="true">#</a> GC日志分析工具</h3><p>（图片资源放上去速度慢，待完善）</p><h2 id="案例" tabindex="-1"><a class="header-anchor" href="#案例" aria-hidden="true">#</a> 案例</h2><h3 id="堆溢出" tabindex="-1"><a class="header-anchor" href="#堆溢出" aria-hidden="true">#</a> 堆溢出</h3><h3 id="元空间溢出" tabindex="-1"><a class="header-anchor" href="#元空间溢出" aria-hidden="true">#</a> 元空间溢出</h3><h3 id="gc-overhead-limit-exceeded" tabindex="-1"><a class="header-anchor" href="#gc-overhead-limit-exceeded" aria-hidden="true">#</a> GC overhead limit exceeded</h3><h3 id="线程溢出" tabindex="-1"><a class="header-anchor" href="#线程溢出" aria-hidden="true">#</a> 线程溢出</h3>',17);function G(b,m){const l=h("ExternalLinkIcon");return d(),n("div",null,[o,a("ul",null,[a("li",null,[e("打印GC日志，通过GCviewer或者"),a("a",s,[e("http://gceasy.io来分析信息"),t(l)])]),u,_,f,x]),C])}const M=r(c,[["render",G],["__file","JVM问题排查与性能调优.html.vue"]]);export{M as default};
